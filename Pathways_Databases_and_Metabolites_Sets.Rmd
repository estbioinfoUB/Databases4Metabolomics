---
title: "Pathways Databases and Metabolites Sets"
author: "Alex Sanchez"
date: "2025-11-29"
output:
  html_document:
    toc: TRUE
    toc_depth: 4
    toc_float:
      collapsed: true
      smooth_scroll: true
    code_folding: hide
#   fig_width: 8
#   fig_height: 6
    self_contained: true
    number_sections: true
    df_print: paged
    theme: readable 
knitr:
  opts_chunk:
    echo: true
    cache: false
    prompt: false
    tidy: true
    comment: NA
    message: false
    warning: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

An ennoying problem with metabolomics -as with many other omics- is the difficulty to manage correctly the relation among the objects we work with and their names, let it be to

- Identify them in a database: Given a metabolite with a given *common name* find  out its identifier in one or more  databases. 
  - E.g. *what is the HMDB identifier of the alpha ketoisovaleric acid?*

- Link the names or the IDs of metabolites with other entities, such as pathways, metabolites sets or chemical classes, stored in their specific databases. 
  - E.g. *In which pathways stored in the SMDB database appears  the alpha ketoisovaleric acid.*
  
In an ideal world where all metabolites had unique names, or unique identifers for every metabolite that could be related with their names in different tables/databases etc, that would be a standard problem of managing databases. 

But, of course, this is not the case. Many metabolites can be named by dozens of different names or their variations and even once they are unique not all of them are annotated in all databases.

Once here we are faced with several questions

1. Is there a main reference database that contains
  - most of the metabolites
  - links to other databases

2. How can these resources be queried?

The search for resources quickly leads to some well known resources such as those liste : [The American Metabolomics association](https://www.metabolomicsna.org/mana-databases).

Querying the resources is usually done

- Interactively, using the web interface they provide,
- Programatically, using either APIS also provide by the organizations or systems such as R with Bioconductor packages.

Before discussing specific databases and tools, it is important to clarify how key terms are used throughout the document, in order to avoid ambiguities between metabolites, pathways and more general metabolite groupings.

## Conceptual overview

In practice we are going to deal with:


- **Metabolomics results**, typically represented as a *list of measured or significant metabolites*, encoded through *identifiers from a specific metabolite database*, and  

- **Sources of biological knowledge**, used to support the interpretation of metabolite lists, such as *pathway databases* and *metabolite set databases*.


To avoid ambiguity in the rest of the document, this section clarifies how the terms *metabolite*, *pathway* and *metabolite set* are used, and how they relate to each other in the context of metabolomics analysis.

### Metabolites and metabolite identifiers

A **metabolite** is an individual chemical entity (for example, glucose, lactate or palmitic acid). In computational workflows, metabolites are typically represented by **database-specific identifiers** rather than by names. Common reference systems include HMDB, PubChem, ChEBI and KEGG Compound.

A single metabolite may have multiple identifiers across databases, and different studies or tools may rely on different identifier systems. As a result, metabolomics results should be understood as **lists of metabolite identifiers tied to a specific database**, rather than as abstract metabolite names. This distinction is essential for reproducibility and downstream interpretation.

### Pathways and pathway databases

A **pathway** is a structured representation of a biochemical process, usually described as a network of reactions connecting metabolites through enzymatic steps. Pathways are often defined within a specific biological context, such as an organism or cellular compartment, and may differ across resources in scope and level of detail.

**Pathway databases** curate and organize such biochemical pathways. From a data-analysis perspective, they provide biologically grounded groupings of metabolites and, in many cases, additional structure (e.g. reaction graphs or topology). Well-known examples of pathway databases used in metabolomics include KEGG and SMPDB.

Not all metabolite-related databases are pathway databases. For instance, ChEBI focuses on chemical entities and ontology, but does not define biochemical pathways.

### Metabolite sets and metabolite set databases

A **metabolite set** is any collection of metabolites grouped according to a shared criterion. Pathways represent one important and biologically meaningful type of metabolite set, but they are **not the only one**.

Metabolite sets may be defined based on:
- functional criteria (e.g. pathway membership),  
- chemical or structural properties (e.g. lipid classes, amino acid families),  
- phenotypic or disease-related associations,  
- experimental or targeted panels, or  
- data-driven groupings derived from statistical or network-based analyses.

**Metabolite set databases** curate and organize such groupings. Some pathway databases, such as SMPDB, can also be used as metabolite set resources, depending on the analysis context. Other resources focus primarily on non-pathway sets, such as chemical classes or curated signatures.

These distinctions are central to the rest of the document, which builds on them to discuss how pathway information and metabolite sets can be accessed and used in practical metabolomics workflows.


## Accessing metabolites databases with Bioconductor

In genomics and transcriptomics, Bioconductor has strongly simplified the process of *annotating* all types of features, prroviding a huge number of packages for many types of molecules and technologies. 

Until recently, few packages were available for metabolites and metabolomics. However, in recent times, in parallel with a growing interest for metabolomics,  the scenario has changed and a few packages for annotating metabolites, most of them based on the Human Metabolome Database (HMDB) are available.

Some of these are:

- [metaboliteIDmapping](https://www.bioconductor.org/packages/release/data/annotation/html/metaboliteIDmapping.html)
- [biodbHmdb](https://www.bioconductor.org/packages/release/bioc/html/biodbHmdb.html)
- [hmdbQuery](https://www.bioconductor.org/packages/release/bioc/html/hmdbQuery.html)
- [CompoundDb](https://www.bioconductor.org/packages/release/bioc/html/CompoundDb.html)

With an appropriate use of such packages it may be possible to recover identifiers for metabolites and, for example, prepare these for a Pathway Analysis that can be performed using tools such as

- [enrichmet](https://github.com/biodatalab/enrichmet)
- [metaboAnalystR](https://github.com/xia-lab/MetaboAnalystR)
- [clusterprofiler](https://bioconductor.org/packages/release/bioc/html/clusterProfiler.html)

Other tools such as 

- [Pathview](https://www.bioconductor.org/packages/release/bioc/html/pathview.html) 

can be useful to visualize the results of such analyses.

Different packages exist for perfoming similar operations. A quick illustraion of how to extract the main information tables from them is presented below. More detail can be found in each package vignette.

### metaboliteIDmapping 

The package provides a comprehensive mapping table of nine different Metabolite ID formats and their common name. The data has been collected and merged from four publicly available source, including HMDB, Comptox Dashboard, ChEBI, and the graphite Bioconductor R package.

It can be accessed at: [https://github.com/yigbt/metaboliteIDmapping](https://github.com/yigbt/metaboliteIDmapping)

To install from Bioconductor: 

```{r }
if (!require(metaboliteIDmapping)) 
  BiocManager::install("metaboliteIDmapping")

if (! require(AnnotationHub)) 
  BiocManager::install("AnnotationHub")
```

To access the dabase we first load the package:

```{r}
library(metaboliteIDmapping)
metabolitesMapping
```

Another package is required to manage it (metaboliteIDmaping is a member of a collection of resources managed by this second package).

```{r}
require(AnnotationHub)

ah <- AnnotationHub()
datasets <- query( ah, "metaboliteIDmapping")
```

If we list  "metaboliteIDmapping" datasets available in  *AnnotationHub* we see it has three datasets.

```{r}
length(datasets)

datasets[3]

```

Currently, there are three versions of the mapping table.

- AH79817 represents the original ID mapping containing 9 different ID formats
- AH83115 mapping table which also includes common names for each compound
- AH91792 current version of the table that accounts for tautomers.

For example, the second dataset can be retrieved as follows:

```{r}
metaboData <- ah[["AH91792"]]
dim(metaboData)
metaboData <- metaboData[!is.na(metaboData$HMDB),]
dim(metaboData)
metaboData <- metaboData[!is.na(metaboData$KEGG),]
dim(metaboData)
colnames(metaboData)
head(metaboData)
save(metaboData, file="data/metaboliteIDmapping_HMDB_KEGG.rda")
```

### biodb and biodbHmdb

The [biodb](https://www.bioconductor.org/packages/release/bioc/html/biodb.html) package provides access to standard remote chemical and biological databases (ChEBI, KEGG, HMDB, ...), as well as to in-house local database files (CSV, SQLite), with easy retrieval of entries, access to web services, search of compounds by mass and/or name, and mass spectra matching for LCMS and MSMS. 

Its architecture as a development framework facilitates the development of new database connectors for local projects or inside separate published packages.

The [package vignette](https://www.bioconductor.org/packages/release/bioc/vignettes/biodb/inst/doc/biodb.html) is an excellent introduction on how to use it to connect to a resource and query it for informations.


#### biodbHmdb 

This is an extension package that implements a connector to HMDB Metabolites.

```{r eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
if (!requireNamespace("biodbHmdb", quietly=TRUE))
    BiocManager::install('biodbHmdb')
```

The first step in using `biodbHmdb`, is to create an instance of the `biodb` class `BiodbMain` from the main `biodb` package. This is done by calling the constructor of the class:

```{r eval=FALSE}
mybiodb <- biodb::newInst()
```

During this step the configuration is set up, the cache system is initialized and extension packages are loaded.

After finishing accessing the `biodb` instance **it needs to be terminated with a call to the `terminate()` method**.

In `biodb` the connection to a database is handled by a connector instance that you can get from the factory. biodbHmdb implements a connector to a remote database. Here is the code to instantiate a connector:

```{r eval=FALSE}
conn <- mybiodb$getFactory()$createConn('hmdb.metabolites')
```

The first time this is processed it may take a long time to download the data (~1Gb)


To get the number of entries stored inside the database

```{r eval=FALSE}
conn$getNbEntries()
```

Now, suppose we have a list of metabolites:

```{r eval=FALSE}
ids <- read.table("data/background4ORA-hmdb_id_filtered.tsv", head=FALSE)[,1]
```

To retrieve entries, use:

```{r eval=FALSE}
entries <- conn$getEntry(ids)
entries
```

To convert a list of entries into a dataframe, run:

```{r eval=FALSE}
x <- mybiodb$entriesToDataframe(entries, compute=FALSE)
head(x)
colnames(x)
mymetabTable <- x[,c("accession","comp.super.class","kegg.compound.id" )]
```

When done with a *biodb* instance it has to be terminated, in order to ensure release of resources (file handles, database connection, etc):

```{reval=FALSE}
mybiodb$terminate()
```

<!-- ## MetaboShiny -->

<!-- Biocondutor provides programmatic access to many metabolomics databases. -->

<!-- MetaboSiny, [https://github.com/joannawolthuis/MetaboShiny](https://github.com/joannawolthuis/MetaboShiny) is a package, which is neither in Bioconductor nor in CRAN, that is worth knowing because it grants access to the main metabolomics databases via a graphic (Shiny) interface that allowas querying and downloading data. -->

<!-- Although it seems very promising it is very hard to make it work (it requires to be run on Docker with specific java version) so it is mitted by now. -->


# Pathway databases

Pathway databases provide curated representations of biochemical processes in the form of pathways, typically describing how metabolites are connected through enzymatic reactions. In metabolomics workflows, they are primarily used as sources of biologically grounded metabolite groupings, and in some cases as providers of additional structure that can be exploited by pathway-based analysis methods.

From a practical perspective, pathway databases play a dual role:
- they define **biologically meaningful metabolite sets**, and  
- they act as **reference frameworks** for interpreting metabolite lists in terms of known biochemical processes.

Among the available resources, KEGG and SMPDB are two of the most commonly used pathway databases in metabolomics, although they differ substantially in scope, access mechanisms and degree of integration with computational workflows.

## KEGG

:contentReference[oaicite:0]{index=0} (Kyoto Encyclopedia of Genes and Genomes) is one of the most widely used pathway databases in systems biology and metabolomics. In the context of metabolomics, KEGG pathways describe metabolic processes as networks of reactions linking metabolites, enzymes and genes, typically in an organism-specific manner.

From a workflow point of view, KEGG is particularly relevant because:
- it provides a large and well-established collection of metabolic pathways, and  
- it can be accessed **programmatically from R** through dedicated interfaces.

Access to KEGG pathway information can be achieved in two main ways:
- **Programmatic access**, for example via Bioconductor packages such as `KEGGREST` or related tools, which allow retrieval of pathway definitions and compound memberships directly from R.
- **Graphical access**, through the KEGG web interface, which is often used for exploratory analysis, visualization and manual inspection.

In practice, KEGG pathways are frequently used as pathway-based metabolite sets for enrichment or over-representation analyses, and they often serve as a default reference when a standardized and reproducible pathway resource is required.

## SMPDB

:contentReference[oaicite:1]{index=1} (Small Molecule Pathway Database) is a pathway resource specifically focused on pathways involving small molecules, with a strong emphasis on human metabolism, disease-related pathways and drug metabolism. As such, it is particularly attractive for metabolomics studies with a biomedical or clinical orientation.

Conceptually, SMPDB is clearly a **pathway database**: it defines pathways as structured biochemical processes and provides explicit mappings between pathways and their member metabolites. However, from a practical and computational perspective, SMPDB differs from KEGG in an important way.

Unlike KEGG, SMPDB does not currently have a level of native integration with Bioconductor that allows seamless programmatic access to pathway definitions and metabolite memberships. As a result:
- access to SMPDB pathways is often performed through the **web interface**, and  
- programmatic use typically requires **manual download, parsing and restructuring** of the data.

For this reason, although SMPDB is a pathway database in conceptual terms, it often behaves as a **custom data source** within R-based workflows. Users may need to explicitly construct metabolite sets from SMPDB pathway definitions before they can be used in downstream analyses such as enrichment or pathway-based interpretation.

## Practical implications for metabolomics workflows

The comparison between KEGG and SMPDB highlights an important general point:  
whether a resource is considered a “pathway database” conceptually does not necessarily determine how easily it can be incorporated into a reproducible computational workflow.

In practice, pathway databases differ in:
- their scope and biological focus,  
- the identifier systems they rely on, and  
- the availability of programmatic access.

These differences have direct consequences for how pathway information is retrieved, how metabolite identifiers are mapped, and how pathway-based metabolite sets are constructed and used in downstream analyses. Subsequent sections build on this distinction when discussing custom data sources and user-defined metabolite sets.

# Custom data sources

In spite of the existence of the previous packages, it may be sometimes useful to work with custom data sources, such as those compiled by a lab or obtained from a study.

## Custom dabases from study datasets


File "myProject_map.csv" contains the ids of a dataset that has been obtained in a study. Given the lack of standardization of the molecule names the associated HMDB ids have been processed using [MetaboAnalyst web tool ID converter](https://www.metaboanalyst.ca/MetaboAnalyst/upload/ConvertView.xhtml) and a table has been obtained that becomes the source of names for this dataset.

```{r}
myProject_map <- read.csv("data/myProject_map.csv")
dim(myProject_map)
colnames(myProject_map)
str(myProject_map)
head(myProject_map[,1:7])
save(myProject_map, file="data/myProject_map.Rda")
```

This table can be used directly or connected with those obtained from other sources using some unique identifier such as HMDB.

We can also create a character vector with the hmdn ids that appear in the study.

```{r}
hmdb_study <- unique(na.omit(myProject_map$HMDB))
length(hmdb_study)
# per exemple: 420
head(hmdb_study)
#> [1] "HMDB0008020" "HMDB0007893" "HMDB0007883" ...
```



## Custom databases for specific informations

File `MEGA-r_name-HMDB-ChemicalClasses.xlsx` contains information on the chemical classes associated with the metabolites from the previous study. 

It has been obtained from a distinct source so it may be conveient to link both tables which requires a common identifier to make it possible.

First read the data

```{r}
library(openxlsx)
metabsChemicalClasses<- openxlsx::read.xlsx("data/MEGA-r_name-HMDB-ChemicalClasses.xlsx")
dim(metabsChemicalClasses)
colnames(metabsChemicalClasses)
str(metabsChemicalClasses)
head(metabsChemicalClasses)
save(metabsChemicalClasses, file="data/metabs_chemicalClases.Rda")
```

Both datasets can be combined using a common column such as HMDB, although this may not be necessary.

```{r}
metabsPlusChem <- dplyr::inner_join(myProject_map,
                                    metabsChemicalClasses,
                                    by="HMDB")
dim(myProject_map)
dim(metabsChemicalClasses)
dim(metabsPlusChem)
length(intersect(myProject_map$HMDB,metabsChemicalClasses$HMDB))
```

Notice that the join of both tables increase the number of rows originally in myProject_map, which is probably due to the fact that there may be metabolites appearing in multiple chemical classes.

```{r}
require(dplyr)
summary_join <- list(
  n_myProject = nrow(myProject_map),
  n_metabsChemicalClasses = nrow(metabsChemicalClasses),
  n_common_HMDB = length(intersect(myProject_map$HMDB, metabsChemicalClasses$HMDB)),
  n_rows_joined = nrow(metabsPlusChem),
  n_unique_HMDB_joined = length(unique(metabsPlusChem$HMDB)),
  duplicated_in_metabsChemicalClasses = metabsChemicalClasses %>%
    count(HMDB) %>%
    filter(n > 1) %>%
    nrow()
)

# --- 3. Mostrar el resum de forma clara ------------------------------------
cat("Summary of join results:\n",
    "- myProject_map rows:                ", summary_join$n_myProject, "\n",
    "- metabsChemicalClasses rows:       ", summary_join$n_metabsChemicalClasses, "\n",
    "- Common HMDB IDs:                  ", summary_join$n_common_HMDB, "\n",
    "- Rows after join:                  ", summary_join$n_rows_joined, "\n",
    "- Unique HMDB after join:           ", summary_join$n_unique_HMDB_joined, "\n",
    "- HMDBs duplicated in classes table:", summary_join$duplicated_in_metabsChemicalClasses, "\n")
```


## SMPDB as a custom database

The small molecule pathway database contains a huge number of pathways associated with metabolites through its HMDB identifiers.

Although it is not a "custom" database, one can be built by downloading and linking one file, `smpdb_pathways.csv`, with (around 48000) pathways and a zipped folder that contains the same number of csv files (one per pathway) with the HMDBIds of the IDs in that pathway.

For instance thepathways file looks like this: the

```{r}
smpdb_pathways <- read.csv("data/smpdb_pathways.csv")

dim(smpdb_pathways)
colnames(smpdb_pathways)
str(smpdb_pathways)
head(smpdb_pathways[,1:4])
```

Notice that these are only the pathway identifiers and descriptions. To build an appropriate metabolite set these have to be combined with a huge number of files, each file containing the HMDB identifiers for one pathway in the `smpdb_pathways` data frame.

This has been processed elsewhere, using an ad-hoc function (`build_SMPDB.R`) that generates a list with an item per pathway, each of wich  contains a (nested) list with all the associated metabolite identifiers.

```{r}
load("data/smpdb_pathway.rda")
names(smpdb_pathway)
sapply(smpdb_pathway, head, 3)
```



# Metabolite sets

The databases mentioned above are -except for the `smpdb_pathway` object- mostly  **pairwise mappings between metabolite identifiers across databases**. For example:

```{r}
head(myProject_map[,1:7])
```

While these are useful for working with the individual molecules, for some procedures such as Pathway or Enrichment Analysis we need *Metabolite Sets* relating each set (Pathway, GO term, KEGG id whatever) with the metabolites linked to it.

Although some of these mappings may be available online or through bioconductor packages we are going to build some o them *manually* to have more control on what we work with.

## Metabolite sets based on KEGG pathways [FIRST VERSION]

As discussed above, some programs such as `MetaboAnalystR` return the KEGG ids associated with a list of metabiolites they are not providing the pathway identifier but the **pairwise mappings between metabolite identifiers across databases** —for instance, linking **HMDB IDs** (Human Metabolome Database) to **KEGG compound IDs** (e.g., `C00031`, `C00157`, etc.).

These KEGG identifiers refer to **chemical compounds**, not **pathways**.  

For example:

| HMDB ID | KEGG ID | Meaning |
|----------|----------|---------|
| HMDB0000122 | C00031 | Glucose |
| HMDB0000243 | C00031 | Glucose (duplicate mapping) |
| HMDB0000456 | C00042 | Glutamine |

Each `Cxxxxx` entry represents an individual compound in the **KEGG Compound** database, not a biological pathway. 

For meaningful pathway enrichment analysis, we need to know which **metabolites belong to the same biological pathway**.  
In KEGG, those entities are represented by **pathway identifiers** of the form `mapXXXXX` (or `hsaXXXXX` for human-specific maps), such as:

| Pathway ID | Pathway Name |
|-------------|--------------|
| map00010 | Glycolysis / Gluconeogenesis |
| map00260 | Glycine, serine and threonine metabolism |
| map00620 | Pyruvate metabolism |

Each pathway in KEGG is associated with dozens of **compound IDs** (`Cxxxxx`), and this is the structure that enrichment analysis requires.

### Connecting pathways and HMDB

In order to to **complete the missing link** between metabolites and pathways we must combine two mappings:

1. **KEGG compounds -> HMDB metabolites** . This information is prepared from mappings such as `Food4Brain-name_map.csv`  or  `metaboliteIDmapping_HMDB_KEGG.rda`.

2. **KEGG pathways -> KEGG compounds**. Retrieved directly from the KEGG database using the `KEGGREST` package in R.  
   This provides, for each pathway (`mapXXXXX`), the list of KEGG compound IDs (`Cxxxxx`) involved in it.

By joining these two sources, we can build a comprehensive table of  **pathway -> metabolites (HMDB)**,  which will serve as the true *MetaboliteSet* structure required for enrichment analysis with the `enrichmet` package.

> The *natural* way to store this information is as a nested list, as with SMPDB above. However many programs require this as a table (a data.frame or a `tibble`). To facilitate ease of format change, some functions have been prepared and made available through the `localEnrichment` package.

```{r}
if (!requireNamespace("localEnrichment")) 
  devtools::install_github("aspresearch/localEnrichment")

```


### Obtaining KEG identifiers for metabolites

KEGG-HMDB mappings are available in tables obtained either from custom mappings such as `myProject_map.csv` or from annotation packages such as `metaboliteIDMapping`.

```{r}
library(dplyr)
library(readr)

# 2. Load your mapping file
myProject_map <- read_csv("data/myProject_map.csv", show_col_types = FALSE)
head(myProject_map)

# 3. Keep only relevant columns
kegg_map_1 <- myProject_map %>%
  select(HMDB, KEGG) %>%
  filter(!is.na(KEGG), KEGG != "") %>%
  distinct()

head(kegg_map_1)
```


```{r}
load(file="data/metaboliteIDmapping_HMDB_KEGG.rda")
dim(metaboData)
head(metaboData)
# Check structure
stopifnot(all(c("HMDB","KEGG") %in% colnames(metaboData)))

# 2. Keep relevant columns and clean
kegg_map_2 <- metaboData %>%
  select(HMDB, KEGG) %>%
  filter(!is.na(KEGG), KEGG != "", !is.na(HMDB), HMDB != "") %>%
  distinct()
dim(kegg_map_2)
head(kegg_map_2)
```

To build a metabolite set, the mappings must be combined with another source providing the association between metabolites and pathways as shown below.

```{r}
# =========================================================
# Build KEGG MetaboliteSets for enrichmet:
# - Combines your study mapping (kegg_map_1) + metaboliteIDmapping (kegg_map_2)
# - Queries KEGG pathways via KEGGREST
# - Produces:
#     (A) PathwayVsMetabolites_global  (HMDB por pathway, universo combinado)
#     (B) PathwayVsMetabolites_study   (HMDB por pathway, restringidos a tu estudio)
# - Incluye métricas de cobertura y guardado en .rda
# =========================================================

# 0) Paquetes
req <- c("dplyr", "readr", "KEGGREST", "stringr", "purrr")
to_install <- req[!sapply(req, requireNamespace, quietly = TRUE)]
if (length(to_install)) install.packages(to_install)
library(dplyr); library(readr); library(KEGGREST); library(stringr); library(purrr)

dir.create("data", showWarnings = FALSE)
dir.create("cache", showWarnings = FALSE)

# 1) Cargar mappings (CARREGATS MES AMUNT)

# myProject_map <- read_csv("data/myProject_map.csv", show_col_types = FALSE)
# 
# kegg_map_1 <- myProject_map %>%
#   select(HMDB, KEGG) %>%
#   filter(!is.na(HMDB), HMDB != "", !is.na(KEGG), KEGG != "") %>%
#   distinct()
# 
# load("data/metaboliteIDmapping_HMDB_KEGG.rda")  # debe crear 'metaboData'
# stopifnot(all(c("HMDB","KEGG") %in% colnames(metaboData)))
# 
# kegg_map_2 <- metaboData %>%
#   select(HMDB, KEGG) %>%
#   filter(!is.na(HMDB), HMDB != "", !is.na(KEGG), KEGG != "") %>%
#   distinct()

# 2) Universo del estudio y universo combinado
universe_study <- sort(unique(kegg_map_1$HMDB))
kegg_map_union <- bind_rows(kegg_map_1, kegg_map_2) %>% distinct()

cat("Resumen mappings:\n")
cat(" - N(HMDB estudio) =", length(universe_study), "\n")
cat(" - Pairs estudio   =", nrow(kegg_map_1), "\n")
cat(" - Pairs mappingID =", nrow(kegg_map_2), "\n")
cat(" - Pairs UNION     =", nrow(kegg_map_union), "\n")
cat(" - Intersección HMDB estudio vs mappingID =", 
    length(intersect(kegg_map_1$HMDB, kegg_map_2$HMDB)), "\n\n")

# 3) KEGG pathways → compounds (Cxxxxx) con caché
cache_file <- "cache/kegg_path2compound.rds"
if (file.exists(cache_file)) {
  path2compound <- readRDS(cache_file)
} else {
  message("Consultando KEGG (human pathways)...")
  pathways_hsa <- KEGGREST::keggList("pathway", "hsa")
  pids <- names(pathways_hsa)

  path2compound <- map(pids, function(pid) {
    ent <- try(KEGGREST::keggGet(pid)[[1]], silent = TRUE)
    if (inherits(ent, "try-error") || is.null(ent$COMPOUND)) return(character())
    # ent$COMPOUND: named vector c("C00031"="Glucose", ...)
    comps <- names(ent$COMPOUND)
    comps[!is.na(comps)]
  })
  names(path2compound) <- pids

  # Filtrar pathways vacíos
  path2compound <- path2compound[lengths(path2compound) > 0]
  saveRDS(path2compound, cache_file)
  message("KEGG pathway→compound cache guardado en: ", cache_file)
}

# 4) Tabla pathway–compound
df_path2compound <- tibble(
  Pathway = rep(names(path2compound), lengths(path2compound)),
  KEGG_compound = unlist(path2compound, use.names = FALSE)
)

# 5) Enlazar compound KEGG (Cxxxxx) → HMDB vía kegg_map_union
#    Importante: algunos mappings traen 'cpds' con 'C' mayúscula; normalizamos por si acaso.
normalize_kegg <- function(x) { str_to_upper(trimws(x)) }
df_path2compound <- df_path2compound %>%
  mutate(KEGG_compound = normalize_kegg(KEGG_compound))

kegg_map_union_norm <- kegg_map_union %>%
  mutate(KEGG = normalize_kegg(KEGG))

df_join <- df_path2compound %>%
  inner_join(kegg_map_union_norm, by = c("KEGG_compound" = "KEGG"), relationship = "many-to-many")  %>%
  select(Pathway, HMDB)

# 6) Añadir nombres legibles de pathways
pathways_hsa <- KEGGREST::keggList("pathway", "hsa")
path_names <- as.character(pathways_hsa)
names(path_names) <- names(pathways_hsa)

# 7) Construir sets (GLOBAL y restringidos al ESTUDIO)
PathwayVsMetabolites_global <- df_join %>%
  group_by(Pathway) %>%
  summarise(
    Metabolites = paste(sort(unique(HMDB)), collapse = ","),
    n_total = n_distinct(HMDB),
    .groups = "drop"
  ) %>%
  mutate(PathwayName = path_names[Pathway]) %>%
  arrange(desc(n_total))

PathwayVsMetabolites_study <- df_join %>%
  filter(HMDB %in% universe_study) %>%                      # recorte al universo del estudio
  group_by(Pathway) %>%
  summarise(
    Metabolites = paste(sort(unique(HMDB)), collapse = ","),
    n_in_study = n_distinct(HMDB),
    .groups = "drop"
  ) %>%
  mutate(PathwayName = path_names[Pathway]) %>%
  arrange(desc(n_in_study))

# 8) Unir métricas para diagnóstico (opcional)
sets_diag <- PathwayVsMetabolites_global %>%
  select(Pathway, PathwayName, n_total) %>%
  left_join(
    PathwayVsMetabolites_study %>% select(Pathway, n_in_study),
    by = "Pathway"
  ) %>%
  mutate(
    n_in_study = tidyr::replace_na(n_in_study, 0L),
    coverage_in_study = n_in_study / pmax(n_total, 1)
  ) %>%
  arrange(desc(n_in_study), desc(n_total))

# 9) Filtros aconsejados (ajusta a tu gusto)
min_set_size_study <- 3
PathwayVsMetabolites_study_filt <- PathwayVsMetabolites_study %>%
  filter(n_in_study >= min_set_size_study) %>%
  select(Pathway, PathwayName, Metabolites)

# 10) Build KEGG EnrichmentSet objects (global and study)
```

We now convert the KEGG pathway–metabolite table into two `EnrichmentSet` objects that will be used in downstream enrichment analyses. Both use HMDB IDs as features and KEGG human pathways as sets.

```{r}
library(localEnrichment)

# Taula auxiliar amb ID de pathway (Pathway) i nom humà (PathwayName)
pathway_info <- tibble::tibble(
  Pathway     = names(pathways_hsa),
  PathwayName = as.character(pathways_hsa)
)

# Afegim PathwayName a la taula llarga HMDB–Pathway
df_join_long <- df_join %>%
  dplyr::left_join(pathway_info, by = "Pathway")

# Global KEGG EnrichmentSet: unió de mappings (estudi + metaboliteIDmapping)
KEGGset_global <- buildEnrichmentSet(
  data         = df_join_long,
  id_col       = "HMDB",          # identificador del metabòlit
  category_col = "PathwayName",   # nom humà del pathway
  set_id_col   = "Pathway",       # ID estable de KEGG (p.ex. "path:hsa00010")
  set_name     = "KEGG_pathway_hsa_global",
  source       = "KEGG",
  species      = "Homo sapiens",
  version      = as.character(Sys.Date()),
  description  = "Human KEGG pathways mapped to HMDB via union(study, metaboliteIDmapping)",
  sep          = ";"              # separat per comes a la columna Metabolites
)

# Versió restringida al univers de l’estudi (només HMDBs de universe_study)
df_join_study <- df_join_long %>%
  dplyr::filter(HMDB %in% universe_study)

KEGGset_study <- buildEnrichmentSet(
  data         = df_join_study,
  id_col       = "HMDB",
  category_col = "PathwayName",
  set_id_col   = "Pathway",
  set_name     = "KEGG_pathway_hsa_study",
  source       = "KEGG",
  species      = "Homo sapiens",
  version      = as.character(Sys.Date()),
  description  = "Human KEGG pathways mapped to HMDB, restricted to study universe",
  sep          = ";"
)

# Taules (set_name, Metabolites) per a enrichmet
KEGGset_global_df <- as.MetaboliteSetDataFrame(KEGGset_global, id_type="both")
KEGGset_study_df  <- as.MetaboliteSetDataFrame(KEGGset_study, id_type="both")
```

This process has generated two metabolite set collections based on KEGG. One
contains all available mapped metabolites (`KEGGset_global`), and another
(`KEGGset_study`) contains only those pathways that include at least one metabolite
appearing in the study.
This process has generated two metabolite sets based on KEGG. One with all available metabolites, and another with those sets that conatin at least one metabolitye appearing in the study.

Thes sets are saved to be re-used later and they contain the required pathway-metabolites table as shown:

```{r}
show(KEGGset_study)
show(KEGGset_global)
```

We can keep these objects as such or just save the metabolite sets data frames for later use



## Metabolite sets based on KEGG pathways [SECOND VERSION]

An improved version of the previous section has been prepared implementing metabolite sets for both PubCHem and HMDB identifiers

### Ad-hoc functions to create the sets

First, some *extractor functions* have been prepared to obtain the desired identifiers.


```{r}
library(KEGGREST)

get_kegg_path2compound <- function(cache_file = "cache/kegg_path2compound.rds") {

  # Si ja existeix el fitxer de caché, el carreguem immediatament
  if (file.exists(cache_file)) {
    message("✔ Carregant pathway→compound des de la caché…")
    return(readRDS(cache_file))
  }

  message("⏳ Descarregant KEGG pathways (això pot trigar uns minuts)…")

  # Obtenir llista de pathways humans
  pathways_hsa <- KEGGREST::keggList("pathway", "hsa")
  pids <- names(pathways_hsa)

  # Resultat buit
  path2compound <- vector("list", length(pids))
  names(path2compound) <- pids

  # Bucle amb feedback
  for (i in seq_along(pids)) {
    pid <- pids[i]
    if (i %% 20 == 0) message("   Processant ", i, "/", length(pids))

    ent <- try(KEGGREST::keggGet(pid)[[1]], silent = TRUE)
    if (inherits(ent, "try-error") || is.null(ent$COMPOUND)) {
      path2compound[[i]] <- character()
    } else {
      path2compound[[i]] <- names(ent$COMPOUND)
    }
  }

  # Filtrar pathways buits
  path2compound <- path2compound[lengths(path2compound) > 0]

  # Guardar en caché
  dir.create("cache", showWarnings = FALSE)
  saveRDS(path2compound, cache_file)
  message("✔ Caché guardat a ", cache_file)

  return(path2compound)
}


normalize_kegg <- function(x) {
  toupper(trimws(x))
}

get_kegg_to_hmdb <- function(kegg_map_union) {
  kegg_map_union %>%
    dplyr::filter(!is.na(KEGG), !is.na(HMDB), KEGG != "", HMDB != "") %>%
    dplyr::mutate(KEGG = normalize_kegg(KEGG)) %>%
    dplyr::distinct()
}

get_kegg_to_pubchem <- function(metaboData) {
  metaboData %>%
    dplyr::filter(!is.na(KEGG), !is.na(CID), KEGG != "", CID != "") %>%
    dplyr::mutate(
      KEGG = normalize_kegg(KEGG),
      CID  = trimws(CID)
    ) %>%
    dplyr::select(KEGG, PubChem = CID) %>%
    dplyr::distinct()
}

```

Next a function has been implemented to build a (generic) Metabolite Set based on KEGG, but id-type agnostic (that is, generic)

```{r}
build_kegg_metaboliteset <- function(
    path2compound,        # list: pathway → vector KEGG compounds
    pathway_names,        # named vector: names(path2compound) → pathway labels
    kegg_to_id,           # mapping: KEGG → target ID (HMDB o PubChem)
    id_type               # "HMDB" o "PubChem"
) {

  df_pc <- tibble::tibble(
    Pathway = rep(names(path2compound), lengths(path2compound)),
    KEGG_compound = unlist(path2compound, use.names = FALSE)
  ) %>%
    dplyr::mutate(KEGG_compound = normalize_kegg(KEGG_compound))

  df_join <- df_pc %>%
    dplyr::inner_join(kegg_to_id, by = c("KEGG_compound" = "KEGG")) %>%
    dplyr::mutate(PathwayName = pathway_names[Pathway])

  EnrichmentSet_obj <- buildEnrichmentSet(
    data         = df_join,
    id_col       = id_type,     # HMDB o PubChem
    category_col = "PathwayName",
    set_id_col   = "Pathway",
    set_name     = paste0("KEGG_pathways_hsa_", id_type),
    source       = "KEGG",
    species      = "Homo sapiens",
    version      = as.character(Sys.Date()),
    description  = paste0("KEGG pathways mapped to ", id_type),
    sep          = ";"
  )

  return(EnrichmentSet_obj)
}

```

### Building the enrichment sets

First we obtain the link among Pathways and Metabolites in KEGG. This will be usedas a *bridge* to relate the Pathway names with the Metabolite Ids in other sources such as HMDB or PubChem.

```{r}
# 1. Pathway → KEGG compounds
library(dplyr)
# 1) KEGG pathways → compounds
path2compound <- get_kegg_path2compound()

# 2) Convertir a data frame llarg
df_pc <- tibble::tibble(
  Pathway       = rep(names(path2compound), lengths(path2compound)),
  KEGG_compound = unlist(path2compound, use.names = FALSE)
)

# Normalitzar KEGG compounds
df_pc$KEGG_compound <- normalize_kegg(df_pc$KEGG_compound)

pathway_names <- KEGGREST::keggList("pathway", "hsa") |> as.character()
names(pathway_names) <- names(KEGGREST::keggList("pathway", "hsa"))


```

Next we retrieve the table of metabolites that will be used to build the metabolite sets.

```{r}
library(metaboliteIDmapping)
metaboData <- metabolitesMapping   # tibble 1M rows
head(metaboData)
dim(metaboData)
```

Now, the mapping KEGG-HMDB can be created.

```{r}
kegg_to_hmdb <- metaboData %>%
  dplyr::filter(
    !is.na(KEGG), KEGG != "",
    !is.na(HMDB), HMDB != ""
  ) %>%
  dplyr::mutate(
    KEGG_compound = normalize_kegg(KEGG),
    HMDB = trimws(HMDB)
  ) %>%
  dplyr::distinct(KEGG_compound, HMDB) %>%     # <<< només el que cal
  dplyr::select(KEGG_compound, HMDB)

dim(kegg_to_hmdb)
head(kegg_to_hmdb)
```

And, similarly the mapping KEGG-PubChem.

```{r}
kegg_to_pubchem <- metaboData %>%
  dplyr::filter(
    !is.na(KEGG), KEGG != "",
    !is.na(CID), CID != ""         # PubChem col is CID
  ) %>%
  dplyr::mutate(
    KEGG = normalize_kegg(KEGG),
    PubChem = trimws(CID)
  ) %>%
  dplyr::distinct() %>%
  dplyr::select(KEGG_compound = KEGG, PubChem)

dim(kegg_to_pubchem)
head(kegg_to_pubchem)

```

Finally we can join the two mappings:

```{r}
df_join_hmdb <- df_pc %>%
  inner_join(kegg_to_hmdb, by = "KEGG_compound", relationship = "many-to-many") %>%
  mutate(PathwayName = pathway_names[Pathway]) %>%
  select(Pathway, PathwayName, HMDB)
head(df_join_hmdb)

df_join_pubc <- df_pc %>%
  inner_join(kegg_to_pubchem, by = "KEGG_compound", relationship = "many-to-many") %>%
  mutate(PathwayName = pathway_names[Pathway]) %>%
  select(Pathway, PathwayName, PubChem)
head(df_join_pubc)

```

With these mappings, an `EnrichmentSet` object can be built for every metabolite id type. 


```{r}
library(localEnrichment)
KEGGset_HMDB <- buildEnrichmentSet(
  data         = df_join_hmdb,
  id_col       = "HMDB",
  category_col = "PathwayName",
  set_id_col   = "Pathway",
  set_name     = "KEGG_pathway_HMDB",
  source       = "KEGG",
  species      = "Homo sapiens",
  version      = as.character(Sys.Date()),
  description  = "KEGG pathway to HMDB metabolites via metaboliteIDmapping",
  sep          = ";"
)
summary(KEGGset_HMDB)
head(KEGGset_HMDB@data)
```

```{r}
KEGGset_PubChem <- buildEnrichmentSet(
  data         = df_join_pubc,
  id_col       = "PubChem",
  category_col = "PathwayName",
  set_id_col   = "Pathway",
  set_name     = "KEGG_pathway_PubChem",
  source       = "KEGG",
  species      = "Homo sapiens",
  version      = as.character(Sys.Date()),
  description  = "KEGG pathway to PubChem metabolites via metaboliteIDmapping",
  sep          = ";"
)
summary(KEGGset_PubChem)
head(KEGGset_PubChem@data)
```

To complete the process we can generate the data frame form for each Metabolite Set and save them as binary objects for later use.

```{r}
df_HMDB <- as.MetaboliteSetDataFrame(KEGGset_HMDB, id_type="both")
df_PubChem <- as.MetaboliteSetDataFrame(KEGGset_PubChem, id_type="both")

save (KEGGset_HMDB, df_HMDB, file="results/KEGGset_HMDB.Rda")
save (KEGGset_PubChem, df_PubChem, file="results/KEGGset_PubChem.Rda")
```




### Metabolite sets based on chemical classes

Although chemical classes is a less rich source of sets a Metabolite Set based on them can be built in a similar way as was done with KEGG.

```{r}
require(dplyr)
require(stringr)
require(readr)

# Load your project map
# myProject_map <- read_csv("data/myProject_map.csv")

# Load or construct HMDB → Chemical Class mapping
hmdb_class <- metabsChemicalClasses # columns: HMDB, ChemicalClass

# Normalize IDs and join
chemical_map_union <- myProject_map %>%
  select(Query, HMDB) %>%
  inner_join(hmdb_class, by = "HMDB") %>%
  filter(!is.na(ChemicalClass))

# Optional: tidy up names
chemical_map_union <- chemical_map_union %>%
  mutate(ChemicalClass = str_replace_all(ChemicalClass, "_", " "))

head(chemical_map_union)

```

Given this data structure the function `buildEnrichmentSet` from the `localEnrichment` package can be used to create an object of class `EnrichmentSet` which is internally a list that can be transformed into data.frame (a table). 

```{r}
library(localEnrichment)
ChemicalClassSet <- buildEnrichmentSet(
  data = chemical_map_union,
  id_col = "HMDB",
  category_col = "ChemicalClass",
  set_name = "ChemicalClasses",
  source = "HMDB",
  species = "Homo sapiens",
  sep=";"
)
```

As with KEGG we can separate chemical classes that appear in our study from those that don't, but given the small size of this set this is ommitted.


```{r}
save(ChemicalClassSet, 
     file = "results/ChemicalClassSet_global.rda")
```

Finally, in order to use it with an Enrichment package such as `enrichment`we can coerce the EnrichmentSet into a data.frame:

```{r}
ChemicalClassSet_df <- as.MetaboliteSetDataFrame (ChemicalClassSet, id_type="both")
dim(ChemicalClassSet_df)
head(ChemicalClassSet_df)
```


### Metabolite sets based on SMPDB

A list with all smpdb pathways and the associated HMDBS has been prepared elsewhere.

```{r}
if(is.null(smpdb_pathway))
  load("data/smpdb_pathway.rda")
names(smpdb_pathway)
firstPWs <- names(smpdb_pathway$sets)[1:4]
smpdb_pathway$sets[1:4]
```

The elements of this list contain only the set names. Set identifiers have to be extracted from a complementary object that contains the set names, descriptions and identifiers.


Combining both objects and taking `smpdb_pathways$SMPDB.ID` as set identifier an `EnrichmentSet` object can be created. Notice however that there is a minor diffference in size that has to be dealt with:

```{r}
### Rebuild SMPDB EnrichmentSet correctly ###

# 1) Llista de sets SMPDB → llista de vectors HMDB
list_sets <- smpdb_pathway$sets
stopifnot(is.list(list_sets))

# 2) Pas a format llarg
df_list <- do.call(rbind, lapply(names(list_sets), function(nm) {
  tibble::tibble(
    set_name = nm,
    HMDB = list_sets[[nm]]
  )
}))

# 3) Llegir el fitxer amb els IDs SMPDB
smpdb_df <- read.csv("data/smpdb_pathways.csv", stringsAsFactors = FALSE)

# Comprovem que les columnes esperades existeixen:
stopifnot(all(c("Name", "SMPDB.ID") %in% colnames(smpdb_df)))

# 4) Unió pel nom del pathway
df_long <- df_list |>
  dplyr::left_join(
    smpdb_df |> dplyr::select(Name, SMPDB.ID),
    by = c("set_name" = "Name")
  )

# 5) Verificació mínima
if (any(is.na(df_long$SMPDB.ID))) {
  warning("Some SMPDB pathways in the list have no matching SMPDB.ID in the CSV.")
}

# 6) Construcció de l’EnrichmentSet correcte
SMPDBset <- buildEnrichmentSet(
  data = df_long,
  id_col = "HMDB",
  category_col = "set_name",
  set_id_col = "SMPDB.ID",
  set_name = "SMPDB_pathways",
  source = "SMPDB",
  species = "Homo sapiens",
  sep=";"
)

### Fi de la reconstrucció ###

```

```{r}
SMPDBset
SMPDBset@data |> head()
summary(SMPDBset)
```

The `EnrichmentSet` objects can now converted into a `data.frame`, which is the expected structure for enrichment analysis

```{r}
SMPDBset_df <- as.MetaboliteSetDataFrame(SMPDBset,  id_type ="both")
dim(SMPDBset_df)
head(SMPDBset_df)
```

As in previous cases, we can filter the  EnrichmentSet object taking only  those sets that have at least one metabolite in the study.

```{r}
SMPDBset_study <- filterEnrichmentSet(SMPDBset, hmdb_study)
SMPDBset_study@data |> head()
```

Again this can be converted into a data.frame

```{r}
SMPDBset_study_df <- as.MetaboliteSetDataFrame(SMPDBset_study, id_type="both")
dim(SMPDBset_study_df)
head(SMPDBset_study_df)
```

The collections can be saved as binary files for later use.

```{r}
save(SMPDBset, SMPDBset_df, file= "data/SMPDB_pathways.Rda")
save(SMPDBset_study, SMPDBset_study_df, file= "data/SMPDB_pathways_study.Rda")
```

### A collection of Metabolite Sets

As a summary of all this exploration, we have generated a unified collection of `EnrichmentSet` objects and their corresponding two–column tables (set name and comma–separated HMDB IDs). These can be saved and reused in downstream enrichment analyses (for example with the `enrichmet` package):

- A collection of KEGG - HMDB metabolite sets

  - `KEGGset_global` and `KEGGset_global_df` (KEGG human pathways, global universe)

- An improved version of the previous made for to distinct set of identifiers.

  - `KEGGset_HMDB` and `KEGGset_PubChem`

- Metabolites sets based on Chemical calsses

  - `ChemicalClassSet` and `ChemicalClassSet_df` (HMDB chemical classes)

- Metabolites sets based on teh SMBDB database

  - `SMPDBset` and `SMPDBset_df` (SMPDB pathways)

```{r}
show(KEGGset_HMDB)
KEGGset_HMDB@data |> head()
dim(KEGGset_HMDB@data)
cat("KEGGset_HMDB")
dim(df_HMDB)
head(df_HMDB)

show(KEGGset_PubChem)
KEGGset_PubChem@data |> head()
dim(KEGGset_PubChem@data)
cat("KEGGset_PubChem")
dim(df_PubChem )
head(df_PubChem )


show(ChemicalClassSet)
ChemicalClassSet@data |> head()
dim(ChemicalClassSet@data)
cat("\nChemicalClassSet_df")
dim(ChemicalClassSet_df)
head(ChemicalClassSet_df)

show(SMPDBset)
SMPDBset@data |> head()
dim(SMPDBset@data)
cat("\nSMPDBset_df")
dim(SMPDBset_df)
head(SMPDBset_df)

```

Last, these metabolites will be saved into a binary for further use in Enrichment Analyses studies.


```{r}
save(KEGGset_global, KEGGset_global_df,
     KEGGset_PubChem, df_PubChem,
     KEGGset_HMDB, df_HMDB,
     KEGGset_study,  KEGGset_study_df,
     ChemicalClassSet, ChemicalClassSet_df,
     SMPDBset, SMPDBset_df,
     file = "results/MetaboliteSets_Collection.Rda")
```

These metabolite sets can be manipulated, e.g. converted into/from lists or filtered based on a list of ids with the functions available in package `localEnrichment`

